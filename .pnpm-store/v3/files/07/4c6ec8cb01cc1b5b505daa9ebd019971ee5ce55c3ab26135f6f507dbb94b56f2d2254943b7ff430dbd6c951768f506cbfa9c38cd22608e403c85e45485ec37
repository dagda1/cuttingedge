"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
const core_1 = require("@effection/core");
const format_error_node_1 = require("./format-error-node");
const error_1 = require("./error");
__exportStar(require("./error"), exports);
/**
 * Runs the given operation in a task and returns that task. `main` functions
 * as an entry point to programs written in Effection. That means that your
 * program should only call `main` once, and everything the program does is
 * handled from within `main`. Unlike `run`, `main` automatically prints errors
 * that occurred to the console.
 *
 * Using {@link MainError}, the `main` operation can be aborted without causing
 * a stack trace to be printed to the console.
 *
 * The behaviour of `main` is slightly different depending on the environment it
 * is running in.
 *
 * ### Node
 *
 * When running within node, any error which reaches `main` causes the entire
 * process to exit with an exit code of `1`.
 *
 * Additionally, handlers for `SIGINT` and `SIGTERM` are attached to the
 * process, so that sending an exit signal to the process causes the main task
 * to become halted. This means that hitting CTRL-C on an Effection program
 * using `main` will cause an orderly shutdown and run all finally blocks and
 * ensure operations.
 *
 * ### Browser
 *
 * When running in a browser, The `main` operation gets shut down on the
 * `unload` event.
 */
function main(operation) {
    return core_1.run(function* (task) {
        let interrupt = () => { task.halt(); };
        try {
            process.on('SIGINT', interrupt);
            process.on('SIGTERM', interrupt);
            let name = (operation === null || operation === void 0 ? void 0 : operation.name) || 'entry point';
            return yield core_1.withLabels(operation, {
                name: typeof name == 'string' ? name : 'entry point'
            });
        }
        catch (error) {
            console.error(format_error_node_1.formatError(error));
            if (error_1.isMainError(error)) {
                process.exit(error.exitCode || -1);
            }
            else {
                process.exit(1);
            }
        }
        finally {
            process.off('SIGINT', interrupt);
            process.off('SIGTERM', interrupt);
        }
    }, { labels: { name: "main", platform: "node" } });
}
exports.main = main;
//# sourceMappingURL=node.js.map