/* eslint-disable @typescript-eslint/no-explicit-any */
import { createController } from './controller/controller';
import { swallowHalt } from './halt-error';
import { EventEmitter } from 'events';
import { StateMachine } from './state-machine';
import { addTrace } from './error';
import { createFutureOnRunLoop } from './future';
import { createRunLoop } from './run-loop';
import { isObjectOperation } from './predicates';
import { extractLabels } from './labels';
let COUNTER = 0;
/**
 * Low level interface to create a task which does not have a parent. Normally all
 * tasks are spawned as children of {@link Effection}.root, but on rare occasions it is necessary
 * to create a task outside the normal task hierarchy.
 *
 * @param operation the operation that the task runs
 * @param options the options that the task is configured with
 * @returns the new task
 */
export function createTask(operation, options = {}) {
    let id = ++COUNTER;
    let children = new Set();
    let emitter = new EventEmitter();
    emitter.setMaxListeners(100000);
    let stateMachine = new StateMachine(emitter);
    let result;
    let runLoop = createRunLoop(`task ${id}`);
    let { produce, future } = createFutureOnRunLoop(runLoop);
    let controller;
    let labels = { ...extractLabels(operation), ...options.labels };
    let yieldingTo;
    if (!labels.name) {
        if (!isObjectOperation(operation) && (operation === null || operation === void 0 ? void 0 : operation.name)) {
            labels.name = operation === null || operation === void 0 ? void 0 : operation.name;
        }
        else if (!operation) {
            labels.name = 'suspend';
        }
    }
    let task = {
        id,
        options,
        future,
        get labels() { return labels; },
        get state() { return stateMachine.current; },
        get type() { return options.type || controller.type; },
        get children() { return Array.from(children); },
        get yieldingTo() { return yieldingTo; },
        get resourceTask() { return controller.resourceTask; },
        catchHalt() {
            return future.catch(swallowHalt);
        },
        setLabels(newLabels) {
            labels = { ...labels, ...newLabels };
            emitter.emit('labels', labels);
        },
        run(operation, options = {}) {
            if (stateMachine.current !== 'running') {
                throw new Error('cannot spawn a child on a task which is not running');
            }
            let child = createTask(operation, { scope: task, ...options });
            link(child);
            child.start();
            return child;
        },
        spawn(operation, options = {}) {
            return {
                name: 'spawn',
                *init() {
                    return task.run(operation, options);
                }
            };
        },
        start() {
            runLoop.run(() => {
                if (stateMachine.current === 'pending') {
                    stateMachine.start();
                    controller.start();
                }
            });
        },
        async halt() {
            controller.halt();
            if (stateMachine.current === 'running') {
                stateMachine.halting();
                result = { state: 'halted' };
            }
            shutdown(true);
            await future.catch(() => {
                // TODO: should this catch all errors, or only halt errors?
                // see https://github.com/jnicklas/mini-effection/issues/23
            });
        },
        toJSON() {
            return {
                id: id,
                type: task.type,
                labels: labels,
                state: stateMachine.current,
                yieldingTo: yieldingTo === null || yieldingTo === void 0 ? void 0 : yieldingTo.toJSON(),
                children: Array.from(children).map((c) => c.toJSON()),
            };
        },
        toString() {
            let formattedLabels = Object.entries(labels).filter(([key]) => key !== 'name' && key !== 'expand').map(([key, value]) => `${key}=${JSON.stringify(value)}`).join(' ');
            return [
                [labels.name || 'task', formattedLabels, `[${task.type} ${id}]`].filter(Boolean).join(' '),
                yieldingTo && yieldingTo.toString().split('\n').map(l => '┃ ' + l).join('\n').replace(/^┃ /, `┣ yield `),
                ...Array.from(children).map((c) => c.toString().split('\n').map(l => '┃ ' + l).join('\n').replace(/^┃/, '┣'))
            ].filter(Boolean).join('\n');
        },
        on: (...args) => emitter.on(...args),
        off: (...args) => emitter.off(...args),
        then: (...args) => future.then(...args),
        catch: (...args) => future.catch(...args),
        finally: (...args) => future.finally(...args),
        consume: (...args) => future.consume(...args),
        [Symbol.toStringTag]: `[Task ${id}]`,
    };
    controller = createController(task, operation, {
        runLoop,
        onYieldingToChange(value) {
            yieldingTo = value;
            emitter.emit('yieldingTo', value);
        }
    });
    controller.future.consume((value) => {
        if (stateMachine.isFinalized)
            return;
        if (value.state === 'completed') {
            stateMachine.completing();
            if (!result) {
                result = { state: 'completed', value: value.value };
            }
            shutdown(false);
        }
        else if (value.state === 'errored') {
            stateMachine.erroring();
            result = { state: 'errored', error: addTrace(value.error, task) };
            shutdown(true);
        }
        else if (value.state === 'halted' && stateMachine.current !== 'erroring') {
            stateMachine.halting();
            result = { state: 'halted' };
            shutdown(true);
        }
        finalize();
    });
    function link(child) {
        if (!children.has(child)) {
            child.consume((value) => {
                runLoop.run(() => {
                    if (stateMachine.isFinalized)
                        return;
                    if (value.state === 'errored' && !child.options.ignoreError && !options.ignoreChildErrors) {
                        stateMachine.erroring();
                        result = { state: 'errored', error: addTrace(value.error, task) };
                        controller.halt();
                        shutdown(true);
                    }
                    if (children.has(child)) {
                        children.delete(child);
                        emitter.emit('unlink', child);
                    }
                    finalize();
                });
            });
            children.add(child);
            emitter.emit('link', child);
        }
    }
    function shutdown(force) {
        controller.future.consume(() => {
            let nextChild;
            function haltNextChild() {
                runLoop.run(() => {
                    nextChild = Array.from(children)
                        .reverse()
                        .find((c) => (c !== nextChild) && (force || !c.options.blockParent));
                    if (nextChild) {
                        nextChild.consume(haltNextChild);
                        nextChild.halt();
                    }
                });
            }
            haltNextChild();
        });
    }
    function finalize() {
        if (Array.from(children).length !== 0)
            return;
        if (controller.future.state === 'pending')
            return;
        if (future.state !== 'pending')
            return;
        stateMachine.finish();
        produce(result);
    }
    return task;
}
//# sourceMappingURL=task.js.map