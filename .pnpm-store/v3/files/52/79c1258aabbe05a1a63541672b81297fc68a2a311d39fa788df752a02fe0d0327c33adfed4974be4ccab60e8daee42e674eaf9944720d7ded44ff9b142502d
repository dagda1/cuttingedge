import { createQueue } from '@effection/subscription';
import { spawn } from '@effection/core';
import { matcher } from './match';
import { createBuffer } from './buffer';
/**
 * Create a new stream of values. The given callback operation is run each time
 * someone subscribes to the stream, so it may be invoked multiple times. The
 * stream emits a value each time the `publish` function passed as an argument
 * to the callback is invoked. The stream is closed when the callback function
 * returns, and the return value of the callback is the value the stream closes
 * with.
 *
 * ### Example
 *
 * ```typescript
 * import { main, createStream, sleep, all } from 'effection';
 *
 * main(function*() {
 *   let stream = createStream<number, string>(function*(publish) {
 *     yield sleep(100);
 *     publish(1);
 *     yield sleep(100);
 *     publish(2);
 *     return "I'm done";
 *   });
 *
 *   // we can subscribe multiple times
 *   let result = yield all([
 *     stream.forEach((value) => { console.log(value) }); // => '1', '2'
 *     stream.forEach((value) => { console.log(value) }); // => '1', '2'
 *   ]);
 *   console.log(result) // => ["I'm done", "I'm done"]
 * });
 * ```
 *
 * See [the guide on Streams and Subscriptions](https://frontside.com/effection/docs/guides/collections) for more details.
 */
export function createStream(callback, name = 'stream') {
    let subscribe = (task) => {
        let queue = createQueue(name);
        task.run(function* () {
            let result = yield callback(queue.send);
            queue.closeWith(result);
        }, { labels: { name: 'publisher', expand: false } });
        return queue.subscription;
    };
    function filter(predicate) {
        return createStream((publish) => {
            return stream.forEach((value) => function* () {
                if (predicate(value)) {
                    publish(value);
                }
            });
        }, `${name}.filter()`);
    }
    let stream = {
        subscribe,
        filter,
        *init(task) {
            return subscribe(task);
        },
        match(reference) {
            return stream.filter(matcher(reference));
        },
        grep(search) {
            if (typeof (search) === 'string') {
                return stream.filter((value) => String(value).includes(search));
            }
            else {
                return stream.filter((value) => !!String(value).match(search));
            }
        },
        map(mapper) {
            return createStream((publish) => {
                return stream.forEach((value) => function* () {
                    publish(mapper(value));
                });
            }, `${name}.map()`);
        },
        first() {
            return task => subscribe(task).first();
        },
        expect() {
            return task => subscribe(task).expect();
        },
        forEach(visit) {
            return task => subscribe(task).forEach(visit);
        },
        join() {
            return task => subscribe(task).join();
        },
        collect() {
            return task => subscribe(task).collect();
        },
        toArray() {
            return task => subscribe(task).toArray();
        },
        toBuffer(limit = Infinity) {
            return {
                name: `${name}.buffer(${limit})`,
                *init() {
                    let buffer = createBuffer(limit);
                    yield spawn(stream.forEach((value) => { buffer.push(value); }));
                    return buffer;
                }
            };
        },
        buffered(limit = Infinity) {
            return {
                *init() {
                    let buffer = yield stream.toBuffer(limit);
                    return createStream((publish) => function* () {
                        for (let value of buffer) {
                            publish(value);
                        }
                        return yield stream.forEach(publish);
                    }, `${name}.buffered(${limit})`);
                }
            };
        }
    };
    return stream;
}
//# sourceMappingURL=stream.js.map