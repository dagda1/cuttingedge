"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createQueue = void 0;
const core_1 = require("@effection/core");
/**
 * Creates a new queue. Queues are unlimited in size and sending a message to a
 * queue is always synchronous.
 *
 * ### Example
 *
 * ```typescript
 * import { main, createQueue } from 'effection';
 *
 * main(function*() {
 *   let queue = createQueue<number>();
 *   queue.send(1);
 *   queue.send(2);
 *   queue.send(3);
 *
 *   yield queue.forEach((value) => console.log("got number", value));
 * });
 * ```
 *
 * @param name the name of the returned subscription, useful for debugging
 * @typeParam T the type of the items in the queue
 * @typeParam TClose the type of the value that the queue is closed with
 */
function createQueue(name = 'queue') {
    let waiters = [];
    let values = [];
    let didClose = false;
    let send = (value) => {
        if (didClose) {
            new Error(`tried to publish a value: ${value} on an already finished queue`);
        }
        let next = waiters.pop();
        if (next) {
            next({ value, done: false });
        }
        else {
            values.push({ value, done: false });
        }
    };
    let close = (value) => {
        if (didClose) {
            new Error('tried to close an already closed queue');
        }
        let next = waiters.pop();
        if (next) {
            next({ value, done: true });
        }
        else {
            values.push({ value, done: true });
        }
    };
    let next = () => {
        return core_1.withLabels((task) => {
            let { future, resolve } = core_1.createFuture();
            if (values.length) {
                resolve(values.shift());
            }
            else {
                waiters.push(resolve);
                task.consume(() => {
                    let index = waiters.indexOf(resolve);
                    if (index > -1) {
                        waiters.splice(index, 1);
                    }
                });
            }
            return future;
        }, { name: `${name}.next()` });
    };
    function withName(operationName, operation) {
        return core_1.withLabels(operation, { name: `${name}.${operationName}()`, expand: false });
    }
    let subscription = {
        next,
        close: ((...args) => close(args[0])),
        closeWith: close,
        first() {
            return withName(`first`, function* () {
                let result = yield next();
                if (result.done) {
                    return undefined;
                }
                else {
                    return result.value;
                }
            });
        },
        expect() {
            return withName('expect', function* () {
                let result = yield next();
                if (result.done) {
                    throw new Error('expected to contain a value');
                }
                else {
                    return result.value;
                }
            });
        },
        forEach(visit) {
            return withName('forEach', function* forEach() {
                while (true) {
                    let result = yield next();
                    if (result.done) {
                        return result.value;
                    }
                    else {
                        let operation = visit(result.value);
                        if (operation) {
                            yield operation;
                        }
                    }
                }
            });
        },
        join() {
            return withName('join', subscription.forEach(() => { }));
        },
        collect() {
            return withName('collect', function* () {
                let items = [];
                let result = yield subscription.forEach((item) => function* () { items.push(item); });
                return (function* () {
                    yield* items;
                    return result;
                })();
            });
        },
        toArray() {
            return withName('toArray', function* () {
                return Array.from(yield subscription.collect());
            });
        },
    };
    return {
        send,
        subscription,
        ...subscription,
    };
}
exports.createQueue = createQueue;
//# sourceMappingURL=queue.js.map