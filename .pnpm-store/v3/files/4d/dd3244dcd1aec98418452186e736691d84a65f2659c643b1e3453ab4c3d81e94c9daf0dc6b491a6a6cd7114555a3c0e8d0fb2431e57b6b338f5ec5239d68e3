"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMainError = exports.MainError = void 0;
/**
 * Throwing this error inside of an operation running within {@link main}
 * is a way to abort the program without causing an error to be printed.
 *
 * When `main` fails, usually it will print a full stacktrace of the error it
 * failed with, but if the error was a `MainError`, the stack trace will not be
 * printed. If the optional `message` is given, it is printed instead.
 *
 * When running in node, the `exitCode` can option can be set to exit with a
 * different exit code.
 *
 * ### Example
 *
 * ``` typescript
 * import { main, MainError } from 'effection';
 * import { promises as fs } from 'fs';
 *
 * const { readFile } = fs;
 *
 * main(function*() {
 *   let fileName = process.argv[2];
 *   try {
 *     let content = yield readFile(fileName);
 *     console.log(content.reverse().toString());
 *   } catch(err) {
 *     throw new MainError({ message: `no such file ${fileName}`, exitCode: 200 });
 *   }
 * });
 * ```
 */
class MainError extends Error {
    constructor(options = {}) {
        super(options.message || "");
        this.name = "EffectionMainError";
        this.exitCode = options.exitCode || -1;
    }
}
exports.MainError = MainError;
/**
 * @hidden
 */
function isMainError(error) {
    return error.name === 'EffectionMainError';
}
exports.isMainError = isMainError;
//# sourceMappingURL=error.js.map