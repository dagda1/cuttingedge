{
  "html": "<p>It is common to have multiple staging, UAT and production environments running different code versions. Knowing which version of the frontend code is in which environment is critical for bug fixing or tracking down issues.</p>\n<p>With frontend code, it is often possible to visually check for frontend features such as menu items or visible features that only appear in a specific code version. Visually checking is time-consuming and doomed to failure in most cases.</p>\n<p>A better approach is to render something unique and unambiguous into the markup like the git commit hash of the HEAD commit that is rendered into an invisible div below:</p>\n<p><img src=\"https://res.cloudinary.com/ddospxsc8/image/upload/v1692535661/guid_rbdtxs.png\" alt=\"git hash in hidden div\"></p>\n<p>A git commit hash is a perfect identifier to pinpoint what version of the code is in the current environment. This git commit hash is the current ID of the current HEAD when the code was deployed.</p>\n<p>The hash in the markup can then be an input for the <a href=\"https://git-scm.com/docs/git-show\">git show command</a>, which can display a nice git diff of precisely which commit this hash is pointing at.</p>\n<p><img src=\"https://res.cloudinary.com/ddospxsc8/image/upload/v1692890916/git-show2_pvhq29.png\" alt=\"git show result\"></p>\n<h2>What makes a suitable identifier?</h2>\n<p>I used to parse the version of the code from the package.json file, but this is only sometimes reliable. The version number field of a <code>package.json</code> file will probably not get updated on each commit, while a git commit hash certainly will.</p>\n<h2>CI/CD pipeline is the only place where environment variables should be assigned values</h2>\n<p>Checking <code>.env</code> files of anything into source control will soon become a security hazard. The retrieval and setting of environment variable values should be part of the continuous integration/deployment process (CI/CD), even for something as seemingly innocuous as a git commit hash. Please do not rely on a developer to set this value before each deploy. Every value must be assigned as part of the automated release process.</p>\n<p>In this example, the git commit hash is rendered into a <a href=\"https://remix.run/docs/en/main\">remix-run</a> application that deploys to AWS using <a href=\"https://arc.codes/docs/en/get-started/quickstart\">aws architect</a>.</p>\n<p>There are a few steps to getting this value into the remix application.</p>\n<p>The following github action sets an environment variable called <code>GIT_COMMIT</code> and makes the variable available to the aws architect runtime:</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">architect</span> <span class=\"hljs-string\">deploy</span>\n  <span class=\"hljs-attr\">if:</span> <span class=\"hljs-string\">github.ref</span> <span class=\"hljs-string\">==</span> <span class=\"hljs-string\">'refs/heads/main'</span> <span class=\"hljs-string\">||</span> <span class=\"hljs-string\">startsWith(github.ref,</span> <span class=\"hljs-string\">'refs/tags/v'</span><span class=\"hljs-string\">)</span> <span class=\"hljs-string\">||</span> <span class=\"hljs-string\">github.event_name</span> <span class=\"hljs-string\">==</span> <span class=\"hljs-string\">'pull_request'</span>\n  <span class=\"hljs-attr\">working-directory:</span> <span class=\"hljs-string\">apps/frontendsupport</span>\n  <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|\n    FLAGS=\"\"\n    if [[ \"${{ startsWith(github.ref, 'refs/tags/v') }}\" == true ]]; then\n      FLAGS=\"--production\"\n    else\n      FLAGS=\"--staging\"\n    fi\n</span>\n    <span class=\"hljs-string\">GIT_COMMIT=\"$(git</span> <span class=\"hljs-string\">rev-parse</span> <span class=\"hljs-string\">HEAD)\"</span> <span class=\"hljs-string\">pnpm</span> <span class=\"hljs-string\">arc</span> <span class=\"hljs-string\">deploy</span> <span class=\"hljs-string\">$FLAGS</span> <span class=\"hljs-string\">-v</span> <span class=\"hljs-string\">--prune</span>\n  <span class=\"hljs-attr\">env:</span>\n    <span class=\"hljs-attr\">NODE_ENV:</span> <span class=\"hljs-string\">production</span>\n</code></pre>\n<p>An aws architect <a href=\"https://arc.codes/docs/en/guides/plugins/set\">set plugin</a> is registered in the <code>app.arc</code> file:</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-string\">@plugins</span>\n<span class=\"hljs-string\">set-env</span>\n</code></pre>\n<p>The above configuration will tell the aws architect runtime to expect a file named <code>set-env.js</code> to be at the path <code>src/plugins/set-env</code>.</p>\n<pre><code class=\"hljs language-js:src/plugins/set-env.js\">module.exports = {\n  set: {\n    env({ arc, inventory }) {\n      return {\n        GIT_COMMIT: process.env.GIT_COMMIT,\n      };\n    },\n  },\n};\n</code></pre>\n<p>AWS architect will thankfully ignore <code>.env</code> files and this is the only place where secrets should be accesed and assigned to environment variables. The above code is called a <a href=\"https://arc.codes/docs/en/guides/plugins/set#set.env\">set.env plugin</a> that registers environment variables to all lambdas in the aws architect project.</p>\n<p>If you really must use some form of .env file then the file should be created on the CI/CD server:</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Create</span> <span class=\"hljs-string\">.env</span> <span class=\"hljs-string\">file</span>\n  <span class=\"hljs-attr\">working-directory:</span> <span class=\"hljs-string\">apps/frontendsupport</span>\n  <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|\n    cat &#x3C;&#x3C; EOF > \".env\"\n    GIT_COMMIT=\"$(git rev-parse HEAD)\"\n    EOF\n</span></code></pre>\n<p>Once the environment variable is set, it is available in the application, depending on the build/deployment framework. Remix has the concept of <a href=\"https://remix.run/docs/en/1.19.3/route/loader\">loader functions</a> on the server that provides data to the component rendering the current route</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">loader</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">json</span>({\n    <span class=\"hljs-attr\">ENV</span>: {\n      <span class=\"hljs-attr\">GIT_COMMIT</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">GIT_COMMIT</span>,\n    },\n  });\n}\n</code></pre>\n<p>The hash is then rendered into the markup.</p>\n<pre><code class=\"hljs language-ts\">&#x3C;div style={{ <span class=\"hljs-attr\">display</span>: <span class=\"hljs-string\">\"none\"</span> }}>{data.<span class=\"hljs-property\">ENV</span>.<span class=\"hljs-property\">GIT_COMMIT</span>}&#x3C;/div>\n</code></pre>\n<p>Every time a commit triggers a build, the hash will be unique and will be automatically rendered into the markup in a div that is invisible to the naked eye.</p>\n<p>Knowing the exact code version of any frontend code is now easy.</p>\n<p>I have been using this trick for a long time and find it invaluable when determining which version of the code is in which environment.</p>",
  "frontmatter": {
    "meta": {
      "title": "How to pinpoint which version of the code is running in any environment",
      "description": "Being able to tell at a glance which version of the code is in which environment is critical.",
      "date": "2023-08-24T00:00:00.000Z",
      "image": "https://res.cloudinary.com/ddospxsc8/image/upload/v1692637878/versioning_gsg8au.png",
      "tags": ["github-actions", "continuous-integration", "devops"]
    }
  }
}
