{
  "html": "<h2>Why never Matters</h2>\n<p>In a language that aims to bring strong typing to JavaScript, a type that indicates the absence of a value seems paradoxical at first. However, the <code>never</code> type has several critical use cases that can make your code more robust and self-explanatory.</p>\n<h3>top and bottom types</h3>\n<p>The concept of a top type and a bottom type has existed in computer programming languages for a long time. Typescript has two top types or universal supertypes, <code>any</code> and <code>unknown</code> and <code>never</code> is the bottom type. The top type can be represented in academia using the $$\\top$$ symbol, and the $$\\bot$$ symbol can represent the bottom type.</p>\n<p>A top type is the supertype of all types, and the bottom type can be known as the subtype of all types.</p>\n<p>Before progressing further, let us define what a supertype and subtype are.</p>\n<h2>supertypes and subtypes</h2>\n<p>A <code>supertype</code> is a generalized entity that can represent common properties. Supertypes exist higher up the hierarchy or near the top because they are more generic and cover more cases. Entities like <code>Animal</code> or <code>Vehicle</code> are good examples of supertypes.</p>\n<p>A <code>subtype</code> is a specialized version of a supertype, e.g. a <code>Dog</code> is a subtype of the <code>Animal</code> supertype or a <code>Car</code> is a subtype of <code>Vehicle</code>. Subtypes exist lower down the hierarchy or near the bottom.</p>\n<p>Below is a simple object hierarchy with <code>Dog</code> as a supertype and <code>Pitbull</code> and <code>Alsation</code> as subtypes of the supertype <code>Dog</code>.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> {}\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Pitbull</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Dog</span> {}\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Alsation</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Dog</span> {}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">walkies</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">dog</span>: <span class=\"hljs-title class_\">Dog</span></span>) {}\n\n<span class=\"hljs-title function_\">walkies</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pitbull</span>());\n<span class=\"hljs-title function_\">walkies</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Alsation</span>());\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">walkies2</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">pitbull</span>: <span class=\"hljs-title class_\">Pitbull</span></span>) {}\n\n<span class=\"hljs-title function_\">walkies2</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Alsation</span>()); <span class=\"hljs-comment\">// wut?  No type error?</span>\n</code></pre>\n<p>The walkies function below takes a <code>dog</code> argument of type <code>Dog</code>. The <code>dog</code> argument can be bound to the <code>Pitbull</code> and <code>Alsation</code> subtypes.</p>\n<p>One interesting point that might catch you out is on line 12 where you might expect to see an error such as:</p>\n<blockquote>\n<p>Argument of type 'Alsation' is not assignable to parameter of type 'Pitbull'.</p>\n</blockquote>\n<p>Typescript uses structural typing and not nominal typing, and all three types (<code>Dog</code>, <code>Alsation</code> and <code>Pitbull</code>) have the same properties (none in this example), so Typescript is happy.</p>\n<p>However, if we add a property to the <code>Pitbull</code> class, then we get the behaviour you would expect:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> {}\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Pitbull</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Dog</span> {\n  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">isJawLocked</span>(): <span class=\"hljs-built_in\">boolean</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lockjaw</span>;\n  }\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">lockjaw</span>: <span class=\"hljs-built_in\">boolean</span></span>) {\n    <span class=\"hljs-variable language_\">super</span>();\n  }\n}\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Alsation</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Dog</span> {}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">walkies2</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">pitbull</span>: <span class=\"hljs-title class_\">Pitbull</span></span>) {}\n\n<span class=\"hljs-title function_\">walkies2</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Alsation</span>()); <span class=\"hljs-comment\">// Argument of type 'Alsation' is not assignable to parameter of type 'Pitbull'.</span>\n<span class=\"hljs-comment\">//Type 'Dog' is missing the following properties from type 'Pitbull': isJawLocked, lockjaw</span>\n</code></pre>\n<h2>Never is Typescript's Bottom Type</h2>\n<p>Wikipedia gives the following explanation for a bottom type, while slightly confusing, enforces the point that no type can be a subtype of the bottom type and is therefore at the bottom of the hierarchy:</p>\n<blockquote>\n<p>the bottom type is a subtype of all other types</p>\n</blockquote>\n<p>Below is an example that will help us to illustrate the point:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> A = <span class=\"hljs-built_in\">never</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">\"a\"</span> | <span class=\"hljs-number\">1</span> | <span class=\"hljs-literal\">true</span> | <span class=\"hljs-literal\">false</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>You might have expected type <code>A</code> to be false, but it is true. Type <code>A</code> is true because <code>never</code> is the subtype of all other types; therefore, it must extend the type on the right of the <code>extends</code> keyword and equate to <code>true</code>.</p>\n<p>Similarly, the same is true of a tuple of <code>never</code> below:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> A = [<span class=\"hljs-built_in\">never</span>] <span class=\"hljs-keyword\">extends</span> [<span class=\"hljs-string\">\"a\"</span> | <span class=\"hljs-number\">1</span> | <span class=\"hljs-literal\">true</span> | <span class=\"hljs-literal\">false</span>] ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>If <code>never</code> is the subtype of all types, then <code>[never]</code> must also extend all tuple types.</p>\n<h2>Never, returning never in Boolean conditional type</h2>\n<p>A fascinating point is below with the <code>IsNever</code> type, which we want to return <code>true</code> if a type equates to <code>never</code>:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">IsNever</span>&#x3C;T> = T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">never</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n\n<span class=\"hljs-keyword\">type</span> A = <span class=\"hljs-title class_\">IsNever</span>&#x3C;<span class=\"hljs-built_in\">never</span>>; <span class=\"hljs-comment\">// never</span>\n</code></pre>\n<p>Wut? Why am I not getting <code>true</code> here??</p>\n<p>The reason is that <code>never</code> is a bottom type and can be considered an empty union with no values. It is like a union with 0 members or no values, and the distribution effectively stops dead, which is why <code>never</code> is returned.</p>\n<p>Fortunately, there is a way around this below:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">IsNever</span>&#x3C;T> = [T] <span class=\"hljs-keyword\">extends</span> [<span class=\"hljs-built_in\">never</span>] ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;\n\n<span class=\"hljs-keyword\">type</span> A = <span class=\"hljs-title class_\">IsNever</span>&#x3C;<span class=\"hljs-built_in\">never</span>>; <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-keyword\">type</span> B = <span class=\"hljs-title class_\">IsNever</span>&#x3C;<span class=\"hljs-built_in\">string</span>>; <span class=\"hljs-comment\">// false</span>\n</code></pre>\n<p>In the code example above, both <code>[T]</code> and <code>[never]</code> are tuples, and this will force the distribution and either true or false will be returned depending on the type of the generic argument <code>T</code>.</p>\n<p>The <code>IsNever</code> type example helped me to understand why exactly <code>never</code> can stop the distribution of a conditional type.</p>\n<p>The <code>never</code> type in Typescript is not a direct equivalent to the formal definition of a bottom type but is the closest in terms of concept. Where <code>never</code> deviates from the standard explanation is that <code>never</code> can be assigned to any other type.</p>\n<p>Another example of the bottom type having no value is that if a function returns the bottom type, it cannot return any value.</p>\n<p>Examples of functions that return <code>never</code>:</p>\n<h3>A function that throws an error:</h3>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throwError</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">message</span>: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">never</span> {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(message);\n}\n</code></pre>\n<h3>A function with an unreachable end:</h3>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">infiniteLoop</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-built_in\">never</span> {\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {}\n}\n</code></pre>\n<h2>Practical uses of never</h2>\n<p>The <code>never</code> type has some efficient benefits:</p>\n<h3>Using type assertions with never</h3>\n<p>If you're doing exhaustive type checks, you can leverage the <code>never</code> type to ensure that all switch statement cases are handled at compile-time.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Fruit</span> = <span class=\"hljs-string\">\"apple\"</span> | <span class=\"hljs-string\">\"orange\"</span> | <span class=\"hljs-string\">\"banana\"</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getFruitInfo</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">fruit</span>: <span class=\"hljs-title class_\">Fruit</span></span>) {\n  <span class=\"hljs-keyword\">switch</span> (fruit) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"apple\"</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"It's red\"</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"orange\"</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"It's orange\"</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"banana\"</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"It's yellow\"</span>;\n    <span class=\"hljs-attr\">default</span>:\n      <span class=\"hljs-comment\">// If we add another fruit to the Fruit type and forget to handle it here,</span>\n      <span class=\"hljs-comment\">// TypeScript will error at compile time because the type of `fruit` would not be `never`.</span>\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">exhaustiveCheck</span>: <span class=\"hljs-built_in\">never</span> = fruit;\n      <span class=\"hljs-keyword\">return</span> exhaustiveCheck;\n  }\n}\n</code></pre>\n<h3>Filtering union types</h3>\n<p>Typescript comes with a builtin utility type <a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers\">Exclude</a>.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Exclude</span>&#x3C;T, U> = T <span class=\"hljs-keyword\">extends</span> U ? <span class=\"hljs-built_in\">never</span> : T;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-variable constant_\">T1</span> = <span class=\"hljs-title class_\">Exclude</span>&#x3C;<span class=\"hljs-string\">\"a\"</span> | <span class=\"hljs-string\">\"b\"</span> | <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-string\">\"a\"</span> | <span class=\"hljs-string\">\"b\"</span>>; <span class=\"hljs-comment\">// Result: 'c'</span>\n</code></pre>\n<p>The <code>Exclude</code> type iterates over each member of the union <code>T</code> and checks if it extends any type in the union <code>U</code>. If it does, it excludes that member from the resulting union by turning it into <code>never</code>.</p>\n<p>You can also use <code>never</code> to conditionally filter types in more complex scenarios, for instance, filtering out types that have a certain property:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">FilterOutWithProperty</span>&#x3C;T, K <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>> = T <span class=\"hljs-keyword\">extends</span> { [key <span class=\"hljs-keyword\">in</span> K]: <span class=\"hljs-built_in\">any</span> }\n  ? <span class=\"hljs-built_in\">never</span>\n  : T;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Candidates</span> = { <span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span> } | { <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-attr\">c</span>: <span class=\"hljs-built_in\">string</span> } | { <span class=\"hljs-attr\">d</span>: <span class=\"hljs-built_in\">boolean</span> };\n\n<span class=\"hljs-comment\">// Will only have { d: boolean }</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Result</span> = <span class=\"hljs-title class_\">FilterOutWithProperty</span>&#x3C;<span class=\"hljs-title class_\">Candidates</span>, <span class=\"hljs-string\">\"a\"</span> | <span class=\"hljs-string\">\"b\"</span>>;\n</code></pre>\n<p>In this example, we define a <code>FilterOutWithProperty</code> type that filters out types that contain a property with the key <code>K</code>. It uses a conditional type to check whether the property exists, and if it does, the type is filtered out by turning it into <code>never</code>.</p>\n<h2>Never say never again</h2>\n<p>In summary, <code>never</code> is a compelling concept in TypeScript with many practical uses. It is also super interesting to geek out on concepts such as top and bottom types which have existed for a long time.</p>",
  "frontmatter": {
    "meta": {
      "title": "Never say never again, A deep dive into Typescript's never type",
      "description": "In TypeScript, there are two top types unknown and any, and never is the only bottom type",
      "date": "2023-08-30T00:00:00.000Z",
      "image": "https://res.cloudinary.com/ddospxsc8/image/upload/v1692641451/top_dc610r.png",
      "tags": ["github-actions", "continuous-integration"]
    }
  }
}
